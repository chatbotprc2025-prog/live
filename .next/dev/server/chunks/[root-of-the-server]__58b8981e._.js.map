{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/TECHNOSOFT/Downloads/test-main/PCE_Assistant-main/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\n// Lazy initialization - only create client when first accessed\nfunction getPrismaClient(): PrismaClient {\n  if (globalForPrisma.prisma) {\n    return globalForPrisma.prisma;\n  }\n\n  // Safely get and clean DATABASE_URL\n  const rawDatabaseUrl = process.env.DATABASE_URL;\n  if (!rawDatabaseUrl || typeof rawDatabaseUrl !== 'string') {\n    throw new Error('DATABASE_URL environment variable is not set. Please add it to your .env file.');\n  }\n  \n  // Ensure it's a string and clean it\n  let databaseUrl: string;\n  try {\n    databaseUrl = String(rawDatabaseUrl).trim();\n    if (databaseUrl) {\n      databaseUrl = databaseUrl.replace(/^[\"']|[\"']$/g, '');\n    }\n  } catch (error) {\n    throw new Error(`Failed to parse DATABASE_URL: ${error}`);\n  }\n  \n  if (!databaseUrl) {\n    throw new Error('DATABASE_URL is empty after parsing.');\n  }\n  let client: PrismaClient;\n\n  if (databaseUrl && databaseUrl.startsWith('file:')) {\n    // SQLite - use better-sqlite3 adapter (required for Prisma 7)\n    try {\n      const { PrismaBetterSqlite3 } = require('@prisma/adapter-better-sqlite3');\n      const Database = require('better-sqlite3');\n      const path = require('path');\n      \n      // Extract database path from DATABASE_URL\n      // Format: \"file:./prisma/dev.db\" or \"file:///absolute/path\" or \"file://relative/path\"\n      let dbPath = databaseUrl.replace(/^file:/i, '').replace(/^\\/+/, '');\n      dbPath = dbPath.replace(/^[\"']|[\"']$/g, ''); // Remove quotes\n      \n      // Handle relative paths\n      if (dbPath.startsWith('./')) {\n        dbPath = dbPath.substring(2);\n      }\n      \n      // Resolve to absolute path\n      const absolutePath = path.resolve(process.cwd(), dbPath);\n      \n      // Create adapter - pass config object with url property\n      const adapter = new PrismaBetterSqlite3({\n        url: absolutePath,\n      });\n      \n      client = new PrismaClient({\n        adapter,\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : [],\n      });\n    } catch (error: any) {\n      console.error('Failed to initialize SQLite with adapter:', error);\n      console.error('Database URL:', databaseUrl);\n      console.error('Error details:', error?.message, error?.stack);\n      throw new Error(`Failed to initialize Prisma with SQLite: ${error?.message || error}`);\n    }\n  } else if (databaseUrl.startsWith('postgresql://') || databaseUrl.startsWith('postgres://')) {\n    // PostgreSQL - use adapter\n    try {\n      const { PrismaPg } = require('@prisma/adapter-pg');\n      const { Pool } = require('pg');\n      const pool = new Pool({ connectionString: databaseUrl });\n      const adapter = new PrismaPg(pool);\n      client = new PrismaClient({\n        adapter,\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : [],\n      });\n    } catch (error) {\n      console.error('Failed to create postgres adapter:', error);\n      client = new PrismaClient({\n        log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : [],\n      });\n    }\n  } else {\n    // Default: try standard client\n    client = new PrismaClient({\n      log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : [],\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    globalForPrisma.prisma = client;\n  }\n\n  return client;\n}\n\n// Export a proxy that lazily initializes the client\nexport const prisma = new Proxy({} as PrismaClient, {\n  get(_target, prop) {\n    const client = getPrismaClient();\n    const value = (client as any)[prop];\n    if (typeof value === 'function') {\n      return value.bind(client);\n    }\n    return value;\n  },\n}) as PrismaClient;\n\nexport default prisma;\n\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,kBAAkB;AAIxB,+DAA+D;AAC/D,SAAS;IACP,IAAI,gBAAgB,MAAM,EAAE;QAC1B,OAAO,gBAAgB,MAAM;IAC/B;IAEA,oCAAoC;IACpC,MAAM,iBAAiB,QAAQ,GAAG,CAAC,YAAY;IAC/C,IAAI,CAAC,kBAAkB,OAAO,mBAAmB,UAAU;QACzD,MAAM,IAAI,MAAM;IAClB;IAEA,oCAAoC;IACpC,IAAI;IACJ,IAAI;QACF,cAAc,OAAO,gBAAgB,IAAI;QACzC,IAAI,aAAa;YACf,cAAc,YAAY,OAAO,CAAC,gBAAgB;QACpD;IACF,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,OAAO;IAC1D;IAEA,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,IAAI;IAEJ,IAAI,eAAe,YAAY,UAAU,CAAC,UAAU;QAClD,8DAA8D;QAC9D,IAAI;YACF,MAAM,EAAE,mBAAmB,EAAE;YAC7B,MAAM;YACN,MAAM;YAEN,0CAA0C;YAC1C,sFAAsF;YACtF,IAAI,SAAS,YAAY,OAAO,CAAC,WAAW,IAAI,OAAO,CAAC,QAAQ;YAChE,SAAS,OAAO,OAAO,CAAC,gBAAgB,KAAK,gBAAgB;YAE7D,wBAAwB;YACxB,IAAI,OAAO,UAAU,CAAC,OAAO;gBAC3B,SAAS,OAAO,SAAS,CAAC;YAC5B;YAEA,2BAA2B;YAC3B,MAAM,eAAe,KAAK,OAAO,CAAC,QAAQ,GAAG,IAAI;YAEjD,wDAAwD;YACxD,MAAM,UAAU,IAAI,oBAAoB;gBACtC,KAAK;YACP;YAEA,SAAS,IAAI,6IAAY,CAAC;gBACxB;gBACA,KAAK,uCAAyC;oBAAC;oBAAS;iBAAO,GAAG;YACpE;QACF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,6CAA6C;YAC3D,QAAQ,KAAK,CAAC,iBAAiB;YAC/B,QAAQ,KAAK,CAAC,kBAAkB,OAAO,SAAS,OAAO;YACvD,MAAM,IAAI,MAAM,CAAC,yCAAyC,EAAE,OAAO,WAAW,OAAO;QACvF;IACF,OAAO,IAAI,YAAY,UAAU,CAAC,oBAAoB,YAAY,UAAU,CAAC,gBAAgB;QAC3F,2BAA2B;QAC3B,IAAI;YACF,MAAM,EAAE,QAAQ,EAAE;YAClB,MAAM,EAAE,IAAI,EAAE;YACd,MAAM,OAAO,IAAI,KAAK;gBAAE,kBAAkB;YAAY;YACtD,MAAM,UAAU,IAAI,SAAS;YAC7B,SAAS,IAAI,6IAAY,CAAC;gBACxB;gBACA,KAAK,uCAAyC;oBAAC;oBAAS;iBAAO,GAAG;YACpE;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sCAAsC;YACpD,SAAS,IAAI,6IAAY,CAAC;gBACxB,KAAK,uCAAyC;oBAAC;oBAAS;iBAAO,GAAG;YACpE;QACF;IACF,OAAO;QACL,+BAA+B;QAC/B,SAAS,IAAI,6IAAY,CAAC;YACxB,KAAK,uCAAyC;gBAAC;gBAAS;aAAO,GAAG;QACpE;IACF;IAEA,wCAA2C;QACzC,gBAAgB,MAAM,GAAG;IAC3B;IAEA,OAAO;AACT;AAGO,MAAM,SAAS,IAAI,MAAM,CAAC,GAAmB;IAClD,KAAI,OAAO,EAAE,IAAI;QACf,MAAM,SAAS;QACf,MAAM,QAAQ,AAAC,MAAc,CAAC,KAAK;QACnC,IAAI,OAAO,UAAU,YAAY;YAC/B,OAAO,MAAM,IAAI,CAAC;QACpB;QACA,OAAO;IACT;AACF;uCAEe"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/TECHNOSOFT/Downloads/test-main/PCE_Assistant-main/lib/auth.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { prisma } from './prisma';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';\n\nexport interface JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n}\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 10);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n\nexport function generateToken(payload: JWTPayload): string {\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });\n}\n\nexport function verifyToken(token: string): JWTPayload | null {\n  try {\n    return jwt.verify(token, JWT_SECRET) as JWTPayload;\n  } catch {\n    return null;\n  }\n}\n\nexport function getTokenFromRequest(request: NextRequest): string | null {\n  return request.cookies.get('auth-token')?.value || null;\n}\n\nexport async function getCurrentUser(request: NextRequest): Promise<JWTPayload | null> {\n  const token = getTokenFromRequest(request);\n  if (!token) return null;\n  \n  const payload = verifyToken(token);\n  if (!payload) return null;\n  \n  // Verify user still exists\n  const user = await prisma.user.findUnique({\n    where: { id: payload.userId },\n  });\n  \n  if (!user) return null;\n  \n  return payload;\n}\n\nexport function setAuthCookie(response: NextResponse, token: string): void {\n  response.cookies.set('auth-token', token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 60 * 60 * 24 * 7, // 7 days\n    path: '/',\n  });\n}\n\nexport function clearAuthCookie(response: NextResponse): void {\n  response.cookies.delete('auth-token');\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAQtC,eAAe,aAAa,QAAgB;IACjD,OAAO,8IAAM,CAAC,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,IAAY;IACjE,OAAO,8IAAM,CAAC,OAAO,CAAC,UAAU;AAClC;AAEO,SAAS,cAAc,OAAmB;IAC/C,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,YAAY;QAAE,WAAW;IAAK;AACzD;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS,oBAAoB,OAAoB;IACtD,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,eAAe,SAAS;AACrD;AAEO,eAAe,eAAe,OAAoB;IACvD,MAAM,QAAQ,oBAAoB;IAClC,IAAI,CAAC,OAAO,OAAO;IAEnB,MAAM,UAAU,YAAY;IAC5B,IAAI,CAAC,SAAS,OAAO;IAErB,2BAA2B;IAC3B,MAAM,OAAO,MAAM,yHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACxC,OAAO;YAAE,IAAI,QAAQ,MAAM;QAAC;IAC9B;IAEA,IAAI,CAAC,MAAM,OAAO;IAElB,OAAO;AACT;AAEO,SAAS,cAAc,QAAsB,EAAE,KAAa;IACjE,SAAS,OAAO,CAAC,GAAG,CAAC,cAAc,OAAO;QACxC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,KAAK,KAAK,KAAK;QACvB,MAAM;IACR;AACF;AAEO,SAAS,gBAAgB,QAAsB;IACpD,SAAS,OAAO,CAAC,MAAM,CAAC;AAC1B"}},
    {"offset": {"line": 290, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/TECHNOSOFT/Downloads/test-main/PCE_Assistant-main/lib/learningEngine.ts"],"sourcesContent":["import { prisma } from './prisma';\n\n/**\n * Adaptive Learning Engine\n * \n * This module enables the chatbot to learn from admin-provided knowledge base entries\n * and improve its understanding over time.\n */\n\ninterface LearnedPattern {\n  keywords: string[];\n  relatedTerms: string[];\n  knowledgeIds: string[];\n  usageCount: number;\n  lastUsed: Date;\n}\n\ninterface KnowledgeRelationship {\n  sourceId: string;\n  targetId: string;\n  relationshipType: 'similar' | 'related' | 'follows';\n  strength: number;\n}\n\n// In-memory cache for learned patterns (could be persisted to DB in future)\nlet learnedPatterns: Map<string, LearnedPattern> = new Map();\nlet knowledgeRelationships: Map<string, KnowledgeRelationship[]> = new Map();\nlet dynamicSynonyms: Map<string, Set<string>> = new Map();\n\n/**\n * Extract keywords and important terms from knowledge base entry\n */\nfunction extractKeywords(text: string, name: string): string[] {\n  const combined = `${name} ${text}`.toLowerCase();\n  \n  // Remove common stop words\n  const stopWords = new Set([\n    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with',\n    'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be', 'have', 'has', 'had',\n    'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they',\n    'what', 'which', 'who', 'where', 'when', 'why', 'how', 'all', 'each', 'every',\n    'both', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not',\n    'only', 'own', 'same', 'so', 'than', 'too', 'very', 'just', 'about', 'into',\n    'can', 'will', 'would', 'could', 'should', 'may', 'might', 'must'\n  ]);\n  \n  // Extract meaningful words (3+ characters, not stop words)\n  const words = combined\n    .replace(/[^\\w\\s]/g, ' ')\n    .split(/\\s+/)\n    .filter(w => w.length >= 3 && !stopWords.has(w));\n  \n  // Count word frequency\n  const wordFreq = new Map<string, number>();\n  words.forEach(word => {\n    wordFreq.set(word, (wordFreq.get(word) || 0) + 1);\n  });\n  \n  // Return top keywords (words that appear multiple times or are in the name)\n  const nameWords = new Set(name.toLowerCase().split(/\\s+/).filter(w => w.length >= 3));\n  const keywords = Array.from(wordFreq.entries())\n    .filter(([word, count]) => count >= 2 || nameWords.has(word))\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 15)\n    .map(([word]) => word);\n  \n  return keywords;\n}\n\n/**\n * Find related terms by analyzing knowledge base content\n */\nfunction findRelatedTerms(knowledgeEntries: any[]): Map<string, Set<string>> {\n  const termCooccurrence = new Map<string, Map<string, number>>();\n  \n  knowledgeEntries.forEach(entry => {\n    const keywords = extractKeywords(entry.text, entry.name);\n    \n    // Build co-occurrence matrix\n    keywords.forEach((word1, i) => {\n      if (!termCooccurrence.has(word1)) {\n        termCooccurrence.set(word1, new Map());\n      }\n      const cooccur = termCooccurrence.get(word1)!;\n      \n      keywords.forEach((word2, j) => {\n        if (i !== j) {\n          cooccur.set(word2, (cooccur.get(word2) || 0) + 1);\n        }\n      });\n    });\n  });\n  \n  // Build synonym/related term map\n  const relatedTerms = new Map<string, Set<string>>();\n  const threshold = 2; // Minimum co-occurrence to consider terms related\n  \n  termCooccurrence.forEach((cooccur, term) => {\n    const related = new Set<string>();\n    cooccur.forEach((count, otherTerm) => {\n      if (count >= threshold) {\n        related.add(otherTerm);\n        // Also add reverse relationship\n        if (!relatedTerms.has(otherTerm)) {\n          relatedTerms.set(otherTerm, new Set());\n        }\n        relatedTerms.get(otherTerm)!.add(term);\n      }\n    });\n    if (related.size > 0) {\n      relatedTerms.set(term, related);\n    }\n  });\n  \n  return relatedTerms;\n}\n\n/**\n * Build relationships between knowledge entries\n */\nfunction buildKnowledgeRelationships(knowledgeEntries: any[]): Map<string, KnowledgeRelationship[]> {\n  const relationships = new Map<string, KnowledgeRelationship[]>();\n  \n  knowledgeEntries.forEach((entry1, i) => {\n    const entry1Keywords = new Set(extractKeywords(entry1.text, entry1.name));\n    const entry1Relations: KnowledgeRelationship[] = [];\n    \n    knowledgeEntries.forEach((entry2, j) => {\n      if (i === j) return;\n      \n      const entry2Keywords = new Set(extractKeywords(entry2.text, entry2.name));\n      \n      // Calculate similarity (Jaccard similarity)\n      const intersection = new Set([...entry1Keywords].filter(x => entry2Keywords.has(x)));\n      const union = new Set([...entry1Keywords, ...entry2Keywords]);\n      const similarity = intersection.size / union.size;\n      \n      if (similarity > 0.2) { // 20% similarity threshold\n        entry1Relations.push({\n          sourceId: entry1.id,\n          targetId: entry2.id,\n          relationshipType: similarity > 0.5 ? 'similar' : 'related',\n          strength: similarity,\n        });\n      }\n    });\n    \n    // Sort by strength and keep top 5\n    entry1Relations.sort((a, b) => b.strength - a.strength);\n    relationships.set(entry1.id, entry1Relations.slice(0, 5));\n  });\n  \n  return relationships;\n}\n\n/**\n * Learn from all knowledge base entries\n * This should be called periodically or when new knowledge is added\n */\nexport async function learnFromKnowledgeBase() {\n  try {\n    console.log('ðŸ§  Learning from knowledge base...');\n    \n    // Fetch all knowledge entries\n    const allKnowledge = await prisma.knowledge.findMany({\n      orderBy: { updatedAt: 'desc' },\n    });\n    \n    if (allKnowledge.length === 0) {\n      console.log('No knowledge entries to learn from');\n      return;\n    }\n    \n    // Extract patterns for each knowledge entry\n    const newPatterns = new Map<string, LearnedPattern>();\n    \n    allKnowledge.forEach(entry => {\n      const keywords = extractKeywords(entry.text, entry.name);\n      const type = entry.type.toLowerCase();\n      \n      // Create or update pattern\n      const patternKey = `${type}:${entry.name.toLowerCase()}`;\n      const existingPattern = learnedPatterns.get(patternKey);\n      \n      newPatterns.set(patternKey, {\n        keywords,\n        relatedTerms: [],\n        knowledgeIds: existingPattern \n          ? [...existingPattern.knowledgeIds, entry.id]\n          : [entry.id],\n        usageCount: existingPattern?.usageCount || 0,\n        lastUsed: existingPattern?.lastUsed || new Date(),\n      });\n    });\n    \n    // Find related terms across all knowledge\n    const relatedTerms = findRelatedTerms(allKnowledge);\n    dynamicSynonyms = relatedTerms;\n    \n    // Build knowledge relationships\n    const relationships = buildKnowledgeRelationships(allKnowledge);\n    knowledgeRelationships = relationships;\n    \n    // Update learned patterns\n    learnedPatterns = newPatterns;\n    \n    console.log(`âœ… Learned from ${allKnowledge.length} knowledge entries`);\n    console.log(`   - Extracted ${newPatterns.size} patterns`);\n    console.log(`   - Found ${relatedTerms.size} term relationships`);\n    console.log(`   - Built ${Array.from(relationships.values()).flat().length} knowledge relationships`);\n    \n    return {\n      patternsLearned: newPatterns.size,\n      relationshipsFound: Array.from(relationships.values()).flat().length,\n      termsLearned: relatedTerms.size,\n    };\n  } catch (error) {\n    console.error('Error learning from knowledge base:', error);\n    return null;\n  }\n}\n\n/**\n * Get dynamically learned synonyms for a term\n */\nexport function getLearnedSynonyms(term: string): string[] {\n  const lowerTerm = term.toLowerCase();\n  const synonyms = dynamicSynonyms.get(lowerTerm);\n  return synonyms ? Array.from(synonyms) : [];\n}\n\n/**\n * Get related knowledge entries based on learned relationships\n */\nexport function getRelatedKnowledge(knowledgeId: string, limit = 3): string[] {\n  const relationships = knowledgeRelationships.get(knowledgeId);\n  if (!relationships || relationships.length === 0) {\n    return [];\n  }\n  \n  // Sort by strength and return top related IDs\n  return relationships\n    .sort((a, b) => b.strength - a.strength)\n    .slice(0, limit)\n    .map(rel => rel.targetId);\n}\n\n/**\n * Update usage statistics when knowledge is used\n */\nexport function recordKnowledgeUsage(knowledgeId: string, query: string) {\n  // Find matching pattern\n  for (const [patternKey, pattern] of learnedPatterns.entries()) {\n    if (pattern.knowledgeIds.includes(knowledgeId)) {\n      pattern.usageCount++;\n      pattern.lastUsed = new Date();\n      \n      // Extract query terms and add to related terms if not already present\n      const queryWords = query.toLowerCase().split(/\\s+/).filter(w => w.length >= 3);\n      queryWords.forEach(word => {\n        if (!pattern.relatedTerms.includes(word)) {\n          pattern.relatedTerms.push(word);\n        }\n      });\n      \n      break;\n    }\n  }\n}\n\n/**\n * Get learned patterns for a query\n */\nexport function getLearnedPatterns(query: string): LearnedPattern[] {\n  const queryLower = query.toLowerCase();\n  const queryWords = queryLower.split(/\\s+/).filter(w => w.length >= 3);\n  \n  const matchingPatterns: LearnedPattern[] = [];\n  \n  learnedPatterns.forEach((pattern, key) => {\n    // Check if query matches pattern keywords or related terms\n    const matches = pattern.keywords.some(kw => queryWords.some(qw => qw.includes(kw) || kw.includes(qw))) ||\n                   pattern.relatedTerms.some(rt => queryWords.some(qw => qw.includes(rt) || rt.includes(qw)));\n    \n    if (matches) {\n      matchingPatterns.push(pattern);\n    }\n  });\n  \n  // Sort by usage count (more used = more relevant)\n  matchingPatterns.sort((a, b) => b.usageCount - a.usageCount);\n  \n  return matchingPatterns;\n}\n\n// Lazy initialization flag\nlet isInitialized = false;\nlet initializationPromise: Promise<any> | null = null;\n\n/**\n * Initialize learning on startup (lazy - only runs once)\n */\nexport async function initializeLearning() {\n  if (isInitialized) {\n    return;\n  }\n  \n  if (initializationPromise) {\n    return initializationPromise;\n  }\n  \n  initializationPromise = (async () => {\n    try {\n      console.log('ðŸš€ Initializing adaptive learning engine...');\n      await learnFromKnowledgeBase();\n      isInitialized = true;\n      console.log('âœ… Learning engine ready');\n    } catch (error) {\n      console.error('Error initializing learning engine:', error);\n      initializationPromise = null; // Allow retry\n    }\n  })();\n  \n  return initializationPromise;\n}\n\n/**\n * Ensure learning is initialized (called automatically when needed)\n */\nexport async function ensureInitialized() {\n  if (!isInitialized && !initializationPromise) {\n    await initializeLearning();\n  }\n  return initializationPromise;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/TECHNOSOFT/Downloads/test-main/PCE_Assistant-main/app/api/admin/knowledge/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport { getCurrentUser } from '@/lib/auth';\nimport { learnFromKnowledgeBase, ensureInitialized } from '@/lib/learningEngine';\n\n// GET - List all knowledge entries\nexport async function GET(request: NextRequest) {\n  try {\n    const user = await getCurrentUser(request);\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const searchParams = request.nextUrl.searchParams;\n    const search = searchParams.get('search') || '';\n    const type = searchParams.get('type') || '';\n\n    let where: any = {};\n    \n    if (search) {\n      where.OR = [\n        { name: { contains: search } },\n        { text: { contains: search } },\n        { source: { contains: search } },\n      ];\n    }\n    \n    if (type) {\n      where.type = type;\n    }\n\n    const knowledge = await prisma.knowledge.findMany({\n      where,\n      orderBy: { updatedAt: 'desc' },\n    });\n\n    return NextResponse.json(knowledge);\n  } catch (error) {\n    console.error('Knowledge GET error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// POST - Create new knowledge entry\nexport async function POST(request: NextRequest) {\n  try {\n    const user = await getCurrentUser(request);\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    let body;\n    try {\n      body = await request.json();\n    } catch (parseError) {\n      return NextResponse.json(\n        { error: 'Invalid JSON in request body' },\n        { status: 400 }\n      );\n    }\n\n    const { source, type, name, text, imageUrl, imageDescription } = body;\n\n    if (!source || !type || !name || !text) {\n      return NextResponse.json(\n        { error: 'All fields are required' },\n        { status: 400 }\n      );\n    }\n\n    const knowledge = await prisma.knowledge.create({\n      data: {\n        source: source.trim(),\n        type: type.trim(),\n        name: name.trim(),\n        text: text.trim(),\n        imageUrl: imageUrl && imageUrl.trim() ? imageUrl.trim() : null,\n        imageDescription: imageDescription && imageDescription.trim() ? imageDescription.trim() : null,\n      },\n    });\n\n    // Audit log\n    await prisma.auditLog.create({\n      data: {\n        actorId: user.userId,\n        action: 'KNOWLEDGE_CREATE',\n        entityType: 'Knowledge',\n        entityId: knowledge.id,\n        severity: 'INFO',\n      },\n    });\n\n    // Ensure learning engine is ready, then learn from new knowledge (async, don't wait)\n    ensureInitialized().then(() => {\n      learnFromKnowledgeBase().catch(err => {\n        console.error('Error learning from new knowledge:', err);\n      });\n    }).catch(() => {\n      // If initialization fails, still try to learn\n      learnFromKnowledgeBase().catch(err => {\n        console.error('Error learning from new knowledge:', err);\n      });\n    });\n\n    return NextResponse.json(knowledge, { status: 201 });\n  } catch (error: any) {\n    console.error('Knowledge POST error:', error);\n    console.error('Error details:', {\n      message: error?.message,\n      code: error?.code,\n      meta: error?.meta,\n      stack: error?.stack,\n    });\n    \n    // Ensure we always return valid JSON\n    const errorMessage = error?.message || 'Internal server error';\n    return NextResponse.json(\n      { \n        error: errorMessage,\n        code: error?.code || 'UNKNOWN_ERROR',\n      },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}